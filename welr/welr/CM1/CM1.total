the dpu-ccm shall use dpu-eeprm to access the eeprom
the dpu-tmali shall configure the ping-pong frame limit at startup as specified by tmali_pp_limit provided during initialization  the default value shall be m frames and shall be capable of being modified dynamically
the dpu-tmali shall configure the dci interface data timeout at startup as specified by tmali_timeout provided during initialization  the default value shall be n milliseconds and shall be capable of being modified dynamically
the dpu-tmali shall allocate a ring buffer of size specified by tmali_buffer_size provided during initialization for storing incoming frames of data  the default buffer size shall be 15 mb
the dpu-tmali shall install callbacks for handling all dpu-dci interrupts including error interrupt ping-pong timeout interrupt and ping-pong complete flag interrupt
the dpu-tmali shall provide a function which sets the current event bit ordering mode in the dci driver
the dpu-tmali shall be capable of making data available from the dci to dpu-dpa  dpu-tmali will populate a ring buffer with frames of data for application task retrieval
the dpu-tmali  shall provide tmali_hk to the dpu-ccm on request
the dpu-tmali shall use dpu-dci to communicate with the dci interface
the dpu-ccm shall use dpu-icui to communicate with the icu
the dpu-tmali shall place the starting address of the event ring buffer in tmali_hk
the dpu-tmali shall install a callback routine to respond to the dci error interrupt
the dpu-tmali shall utilize scm_dci_sr along with errno provided by dpu-dci to decode errors and place them on an error queue for dpu-ccm
the dpu-ccm shall provide a mechanism for other cscs to report errors for inclusion in the dpu_hk
the dpu-ccm shall collect a task_hbeat from  dpu-scui dpu-ccm dpu-dcx dpu-tmali and dpu-dpa   non-responsive tasks will be reported in dpu_hk
the dpu-ccm shall record an error to the last_boot_ivec location in eeprom and discontinue strobing the watchdog timer should an unrecoverable software error occur  an unrecoverable software error is defined as an error that causes a loss of commandability or ground communication
the dpu-ccm shall in rejecting a command report an error in dpu_hk indicating  the byte-code of the command being rejected in the lsb of the errno as described in 03691-dpusdp-01
the dpu-ccm shall process real-time non-deferred commands within b ms of receipt from the icu or the scu
the dpu-ccm shall be able to count a consecutively reported error  when the the count for a particular error id exceeds 250 for a particular reporting period the error code will be replaced with a error code sequence which shall include the original error code and the number of times the error was reported
the dpu-ccm shall check the length of a received dpu_cmd against an expected value from a lookup table indexed by function code  if the received value does not match the expected then the command will be discarded and an error will be enqueued
the dpu-ccm shall maintain counts of both the number of commands successfully received and rejected and report the parameters in dpu_hk
the dpu-ccm shall implement a mechanism whereby large memory loads and dumps can be accomplished incrementally command and control csc	the command and control ccm csc is a level 2 reuse component from the instrument y project  the command and control csc includes the following components  a control task ccmctrltask which initializes the dpu fsw and spawns other tasks at bootup schedules the production of dpu housekeeping data packets monitors the execution of other tasks and schedules the execution of other periodic tasks such as the heartbeat message and the watchdog strobe; and  a command dispatch task ccmcmdtask which receives and dispatches real-time commands received from the scu or the icu major data structures include  a static data table that keeps track of the operational state  data included in this table includes housekeeping production rates ccm specific flags and the number of commands executed  a command queue into which commands are placed when they arrive via interrupt from the icu or the scu  an error/event queue which accumulates error and event codes which are reported by the dpu fsw  these error and event codes are removed from the queue and placed into a telemetry packet at a given interval and included in dpu housekeeping data
telescope module access library and interface csc	the telescope module access library and interface tmali csc manages the detector event queue and provides an api for the retrieval of detector events from that queue to the data processing algorithms
telescope module access library and interface csc	the tmali csc includes the following components a queue tmali_event_queue implemented using a ring buffer which contains the detector events which have been received over the data capture interface from the dci driver but which have not yet been retrieved by the dpa csc; an api which facilitates the retrieval of detector events from the queue by the dpa csc  the api consists of the tmalinextevent and tmaliwait functions an set of api functions used by the dpa csc to configure the dci interface including tmalibitarrangementset tmalidciframedepthget tmalidciframedepthset tmalidciwindowset tmalidatatimeoutset and tmalidatatimeoutget  an api housekeeping function tmalihkget which gathers  csc housekeeping data at the request of the command and control task  the task tmalitask and an isr tmalitransfertoqueueisr work together via a semaphore to synchronize the transfer of data from the dci to the  queue an error handling isr tmalidcierrorreportedisr is installed as a hook routine to the dci driver and is used to keep track of the number of errors reported by the dci driver
error collection and reporting	the ccmerrenq may also be called from interrupt context  in interrupt context the mutual exclusion mechanism implemented on the error queue cannot be used since it is illegal to take a semaphore in an interrupt context  to circumvent this limitation the global variable ccmisrerror is set with the appropriate error code  the error will be queued the next time ccmtask runs  due to the manner in which errors are handled in interrupt context it is possible to loose errors if more than one error occurs in interrupt context before ccmtask executes; the previous error will be overwritten by the new error
error collection and reporting	in order to insure that error counts are not lost due to rollover ccmerrenq checks to insure that the count for a given error has not gone above 250 in one high rate housekeeping reporting period  if the error count exceeds 250 for a particular reporting period ccmerrenq will enqueue s_ccm_err_repeat error with the current error count and will clear its error tracking mechanism
error collection and reporting	at boot time no error queue exists because it has yet to be created  errors that occur in this early stage of error reporting are assigned directly to the global task variable errno  the reader may refer to the vxworks programmers guide section 237 for more information on errno  if errno is set after the error queues are created it is queued to the error queue by calling ccmerrenq
error collection and reporting	the dpu-ccm csc provides a centralized error reporting interface ccmerrenq that other fsw tasks use to report errors  each time it wakes ccmtask checks to see if it is time to form an error/event packet for transmission to the ground  if so ccmtask calls ccmhkmkerror to actually create the packet and forward it to dpu-scui for transmission to the ground
error collection and reporting	the s_ccm_err_repeat error encodes the count of the last repeated error in its low order byte  if a new error is reported as discussed above ccmerrenq will enqueue a s_ccm_err_repeat  for any previously repeated error along with the newly reported error   in order to keep the original error codes and their repeated counts together in the same error packet ccmmkhkerr enqueues a special error code s_ccm_errq_flush as a special signal to ccmerrenq that it needs to clear its error tracking mechanism and enqueue any  repeated error counts associated with a particular error
error collection and reporting	the ccmerrenq function tracks the last error reported and its frequency of occurrence  once an error code has been reported it becomes the previously reported error code maintained by ccmerrenq  a repetition count is then incremented for each subsequent consecutively reported identical instance of this previously reported error  if this error code is reported more than once in one high-rate housekeeping reporting period then a special error s_ccm_err_repeat is enqueued with the repetition count for the error encoded in the least significant byte this mechanism effectively reduces the potential for housekeeping telemetry to become flooded with a single repeated error
public functions	this routine provides a means to set dci windowing parameters used by the dci data acquisition  before commanding the dci driver to change the dci hardware windowing parameters the window specification is verified if the setting is incorrect the function returns an error and the hardware windowing function is not activatedthe function both sets the requested hardware window specification and activates the hardware windowing function
public functions	this routine gets housekeeping data stored for the tmali csc including some dci parameters and resets the tmali internal counters to zero  when the caller supplied pointer to a tmali_hk structure is nil no data is returned but the tmali internal counters are still reset to zerotwo of the four error counters are updated within an isr context this requires a task switch safe implementation of these counters  within vxworks this could be solved using a counting semaphore  in the tmali csc design a faster method was used by using a free running error counter and a careful update of the reported number of errors using an extra temporary variable  as the increment and assignment of the 32 bit unsigned integers themselves are atomic operations the resulting counters are task safe and no error events are lost  this means that the sum of the errors reported by the tmalihkget function is equal to the total numbers of errors that occurred no error reports are lost due to the update of the internal structures
public functions	this routine provides a means to get the current data timeout value used by the dci  the returned value is the current timeout in millisecondsthe timeout is discussed in document 036911400 section 432413
public functions	this routine is called by the mil-std-1553 command isr at 1 hz arrival of the clock message to wakeup the ccm control task which blocks on a semaphore after completing its processing
public functions	this routine is called by each dpu fsw task to report that the task has executed so that the ccmctrltask can assess the health of the dpu fsw execution
public functions	this routine is called by any csc in order to report an error or event that should be included in dpu housekeeping  if this routine is called from interrupt context a static global variable ccmisrerror is set so that the error can be enqueued later see ccmctrltask  this is done since the error/event queue is semaphore-protected and a semaphore cannot be taken in an isr  the error queue semaphore has priority inversion set to reduce conflicts between multiple callers should a priority inversion situation arise this routine also replaces frequently occuring errors with a special repeat error code  the repeat error code is a special error code that follows a normally reported error code to indicate that the normally reported error code previously reported has occurred more than once in the last high rate reporting period
public functions	this routine is called by the mil-std-1553 command isr and the ssi interface isr any time a command arrives from the scu or the icu to enqueue the command and to wakeup the ccm command dispatch task so that the command can be executed
public functions	this routine provides a means to set the bit arrangement used by the dci  when bspecialarrangement is true the dci is set to special bit arrangement mode otherwise the default mode of no rearrangement is set
public functions	this function returns the next event in the queue to the caller  the caller should store the value returned by this function in a variable defined locally within the scope of the function from which it is called  if the return value is stored as described above the event value is stored in a rad6000 register rather than memory  processing is therefore much faster since register accesses on the rad6000 are much faster than memory accessesa compilation option tmali_nochecks is provided for the disabling of buffer empty checks this results in slightly faster code but should only be used when the application using this function is known to make proper calls to the function  if the tmali module is compiled with the tmali_nochecks option an improper call to the tmalinextevent function calling it when no data is available in the tmali buffer will compromise the tmali buffer data structurethe queue structure and the related pointers are described in the local tmaliph header file as only the write pointer pout is manipulated here and the operations on the 32 bit pointers themselves are 'atomic' no mutual exclusion problem can occur
public functions	this task initializes the tmali csc and then continues to read data from the dci and store it in the tmali buffer each time the dci driver signals that data is available in the ping-pong buffer  the availability of data in the dci ping-pong buffer is signaled to the tmalitask using a semaphore  unless a fatal error is detected during initialization this task will never terminatethe specified 3 parameters specify the size of the tmali queue and the initial parameters for the dci if the specified values are outside the allowed range default values will be usedthe specified queuesize is the allocated buffersize in 4 byte events the ring buffer is full when queuesize-1 events are stored in the buffer
setting data timeout in dci	during nominal operation frames arrive approximately every 11 msecs  the dci hardware will generate an interrupt if event data has been received in one of the ping-pong buffers and a configurable amount of time has passed during which no additional events have been received  a data timeout interrupt is not an error but rather typically indicates that the current exposure has been completed  the data timeout interrupt allows the tmali csc to retrieve the trailing events from the dci ping-pong buffer  the function tmalidcitimeoutset provides an api to the dci driver to allow the timeout setting to be altered
setting frame depth in dci	the optimum frame depth will be determined with benchmark testing  the default frame depth is 10 frames  given the above data it will take approximately 24 msec to read 10 maximum-sized frames at the maximum data transfer rate
setting hardware windowing		the hardware windowing function of the dci can be activated and controlled  via tmalidciwindowset  this function activates the hardware windowing function and transfers the specified window parameters to the dci driver
setting dci bit arrangement	the bit arrangement of the dci control/status register can be set via tmalibitarrangementset
flight software initialization	the command and control csc is initialized by spawning the ccm control task ccmctrltask from the operating system startup task usrroot  after the task is spawned it calls a function ccminit which creates the error/event queue instantiates needed semaphores and installs various isrs  finally it spawns the remaining tasks which comprise the dpu fsw when the ccm control task starts up it reads dpu configuration startup defaults from the system_config_area in eeprom  if the system_config_area checksum is bad hard-coded defaults are used  the ccm control task initializes the remaining cscs by calling the applicable initialization function or if the csc has an associated task by spawning the task using the vxworks function taskspawn  when the ccm control task initializes a csc it passes the startup defaults read from eeprom as parameters to the task initialization function in addition to its task initialization activities ccminit also initializes the command length verification table by calling ccmcmdlengthinit  the command processor uses the created table to verify expected command lengths for newly received commands
housekeeping	the tmali csc collects housekeeping data that can be retrieved via a call to tmalihkget   tmali csc housekeeping is returned via the tmali_hk data structure
public functions	this function sets the frame depth of the ping-pong buffers used by the dci csc  the frame depth determines how many frames are read into the selected ping-pong buffer before interrupting  the initial value for the frame depth setting is determined by the parameter provided when starting the tmalitask  the maximum value to which the frame depth can be commanded is 64 frames an attempt to command the frame depth to a value larger than this maximum will result in setting the timeout to the default value of v framesthe actual setting of the frame depth could be delayed by a small amount of time if there is activity on the dci bus and is typically changed when the dci has just reported a frame level reached or timeout condition  this minimizes the chance of changing the setting while the hardware is close to detecting a frame event  changing the frame depth while the dci csc is processing data could cause unpredictable results  when a new tmalidciframedepthset command is send before the previous setting has been activated the new request will overwrite the previous request and the dci will be commanded to the new value at the first available opportunity
memory upload and download handling	there are two ways to upload data to the dpu  memory poke d_mem_dat_poke command or  memory upload d_mem_dat_upld command the memory poke command is used when a small <=z bytes of data need to be poked into a dpu memory location  the z byte limitation is derived from the company x command length constraint
memory upload and download handling	when larger amounts of memory must be uploaded to the dpu such as in the case of a software patch or full software upload the regular memory upload is used  memory uploads are accomplished by sending a series of individual d_mem_dat_upld commands resulting in a single virtual upload ccsds-like sequence grouping flags are employed to allow the dpu fsw to accept up to a maximum of 65535 bytes in a single virtual upload  the data contained in each d_mem_dat_upld command is stored in a temporary dram buffer until all of the sequence numbers in the entire upload have been successfully received  when the dpu fsw receives the last command in the series the fsw will verify that all sequence numbers have been received verify the end-end upload checksum and then write the entire temporary buffer to the target location specified in the first upload command
memory upload and download handling	if more than 65535 bytes need to be uploaded the upload file must be broken up into multiple smaller files each less than or equal to 65535 bytes and then each of the virtual uploads should be sent in series  because of the sequence numbers the dpu fsw can receive individual upload commands out of sequence  there is no time limit for the accomplishment of a single virtual upload and so a long upload can continue across ground contacts  if an upload is in progress the last sequence number can be sent to the dpu fsw and it will report the list of missing sequence numbers via event number s_ccm_missing_seqno  if an upload is in progress and needs to be cancelled it can be discarded by issuing the d_mem_dat_cncl command
emory upload and download handling	data can be upload to several types of locations including  dram  eeprom  hardware registers and  eeprom filesystem ial d_mem_dat_upld command specify the target location  if the destination is the eeprom filesystem a block number is provided in lieu of a memory address  which is used by the dpu fsw to formulate a filename of the form eefs1dpu_blk## where ## is the block number  in this case once the entirety of the uploaded data is received by the dpu fsw the uploaded data is then written to that file in the eeprom filesystem  if a file already exists with that name it is overwritten  the eeprom filesystem can be reinitialized using the command d_mem_disk_init
memory upload and download handling 	the command d_mem_blk_dnld is used to download data from a file contained in the eeprom filesystem  as in the upload command only the block number need be provided and the entire contents of the filename formed from the block number will be downloaded  to download data from any location other than the eeprom filesystem the command d_mem_dat_dnld is used  as described previously downloads handled in a deferred fashion to avoid consuming excessive cpu time  a single virtual download will appear on the ground as a series of download packets the contents of which must be extracted and concatenated in order to recreated the original data sequence
command handling	commands are dequeued from the command queue and executed by the command dispatch task ccmcmdtask  this task blocks on a semaphore which is given by ccmcmdenq the ccmcmdtask wakes on the semaphore and calls ccmcmdprocess to process waiting commands  the ccmcmdprocess function subsequently retrieves waiting commands from the command queue and invokes ccmcmddispatch to verify the expected length of the command and execute it  if command echo is enabled ccmcmddispatch will call ccmhkmkcmdecho to blindly echo the command back to the ground  counts for both rejected and executed commands are maintained if the command sent to ccmcmdenq is either a 1 hz clock time message or an attitude message from the spacecraft the command will not be forwarded to the command queue but instead will be executed directly while still in interrupt context  attitude messages are forwarded to dpacommandsend while the 1 hz clock time messages parameters are passed to tistimesync in order to synchronize the current time  any other non dpu or spacecraft observatory messages are quietly discarded without reporting an errorin order to guarantee that ccmcmdtask task reports in with the ccm control task periodically in absence of a ground command the semaphore has a timeout value of 20 seconds  if the semaphore times out the task will verify no commands are on the command queue and then report in to the ccm control task by calling ccmtaskreport
command handling	when a command arrives from the scu via the 1553 interface or the icu via the ssi interface the respective isr will enqueue the command packet into a command queue and then give the semaphore to awaken the ccmcmdtask  since it is possible for the dpu to send a command to itself commands may arrive at interrupt context or task context  therefore the ccm maintains two queues  one for interrupt context which is not semaphore protected and one for task context which is semaphore protected
control and monitoring	the ccm control task also handles memory dump commands  in the event of a data dump command the ccm control task will break the dump into manageable pieces and dump a small portion at a time each time the task is awakened  the purpose of this deferred activity is to prevent a large dump from consuming available cpu time by keeping the high-priority ccm command dispatch task busy for an extended period
control and monitoring	the dpu produces eight types of housekeeping packets
control and monitoring	every time the ccm control executes it calls ccmperprocess to handle periodic processing responsibilities  such responsibilities include analog to digital conversion updates dpu task monitoring icu heartbeat message production and watchdog strobe the ccmhealthchk function called by ccmperprocess verifies the execution of other tasks by monitoring the amount of time that has elapsed since each task last reported  other tasks report their execution to the ccm control task by calling the function ccmtaskreport providing their task index  each task has an expected execution frequency and if a task does not execute as expected an error is reported in dpu housekeeping  if the command dispatch task fails to report for an extended period the dpu will execute a reboot since it is impossible to command the dpu if this task is not executing otherwise it will strobe the watchdog
control and monitoring	the ccm control task initializes the dpu fsw it is the responsibility of the ccm control task to establish a successful boot  it does so by blocking on temporary semaphores each with a 5 second timeout after spawning the scu interface task and the ccm command task  if both of these tasks report a successful initialization by giving the semaphore the ccm control task toggles the bc_index parameter in eeprom to indicate a successful boot  if either task does not report a successful initialization the ccm control task disables the watchdog strobe to effect a reboot of the dpu  the rationale for selecting the successful initialization of these two tasks as the definition of a successful boot is that the dpu fsw requires these tasks as a minimum to establish ground contact and provide commandabilityonce this initialization is complete the task blocks on a binary semaphore which is given by the scui command isr upon arrival of the 1 hz clock message  in the event a clock message does not arrive the semaphore will time out after 15 seconds  the ccm control task remains alive to create and transmit dpu housekeeping at the appropriate intervals perform various periodic processing tasks and to process memory dump commands	the final call to ccmerrenq is performed in order that if an error occurs in an interrupt service routine a global variable is set to the value of the errno which is then enqueued into the error/event queue as part of this tasks normal processing
initialization	the tmali csc is initialized by spawning the tmalitask with the startup default parameters  this task will allocate memory for the tmali_event_queue install dci isrs initialize static variables and data structures and then enter an end-less loop in which it transfers the data from the dci to the tmali queue throttled by the semaphore semdciwait
data transfer to queue	when the tmalitransfertoqueueisr isr is invoked it gives a semaphore to awaken tmalitask that will transfer data to the  queue over the vme bus  the tmalitask uses the read function in the dci driver which implements a data transfer using a high speed assembly language routine  because the tmali ring buffer is implemented as an array the tmalitask function must first examine the tmali_event_queue to determine whether the data resident in the dci buffer can be retrieved using a single read call or whether two calls are required in order to correctly handle the wrap-around case at the end of the ring buffer  in addition the tmalitask function must perform an error check to verify that there is sufficient space to receive the data available in the ping-pong buffer  if there is insufficient space for the complete set of frames the entire contents of the readable ping-pong buffer are discarded and the error s_tmali_queue_full is reported using ccmerrenq mechanism  such discarded data constitutes an integral number of ccd frames since the dci hardware design ensures that ping-pong transitions occur at ccd frame boundaries  this policy of discarding the newer data supports the scientific viewpoint that events collected right after a burst have more scientific value than events collected later
data transfer to queue	once the events in the ping-pong buffer have been completely transferred to the tmali_event_queue the tamlitask function must re-arm the hardware to swap the ping-pong buffer when ready  in the event that tmali does not finish transferring the data from the ping buffer before the pong buffer is full the dci driver will issue an error interrupt invoking the tmalidcierrorreportedisr  in response the tmalidcierrorreportedisr will set an error flag so that the tmalitask can recover  the tmalidcierrorreportedisr also gives the semdciwait semaphore to awaken the tmalitask even though it is likely already awake since it is possible that the tmalitask has just completed transfer of the data at the time the error occurs  the error will also be counted in tmali_hk  the dci hardware will discard events until the tmalitask function completes the prior transfer recognizes the error flag and in response manually forces a ping-pong swap and re-enables data acquisition  this guarantees that only complete frames end up in the ping-pong buffer and will be considered for processing  in normal operation this error should not occur as the tmali task should be fast enough to retrieve data from the dci ping-pong buffer  when events cant be handled fast enough the problem should result in an tmali queue full condition which is reported as an s_tmali_queue_full error using the ccmerrenq mechanism
data transfer to queue	during initialization the tmali csc installs an isr hook routine tmalitransfertoqueueisr  into the dci driver which is invoked when  the dci interface reaches the programmed frame limit in the ping-pong buffer or  the dci interface detects a data receipt timeout
event retrieval from queue	events are retrieved from the tmali_event_queue by the dpa csc via an api consisting of two functions tmaliwait and tmalinextevent  for efficiency the following api usage points are relevant  the dpa csc will inline the tmalinextevent function in order to avoid a function call for each event  the dpa csc will place each event received into a register and complete the processing for a given event while resident in a register before retrieving the next event and  the tmalinextevent function performs no error checking in order to maximize the efficiency of the function  therefore the dpa csc must keep track of the number of events retrieved versus the number provided in return from tmaliwait
ring buffer data structure	the  csc maintains a fifo implemented as a ring buffer to temporarily store the data received from the dci before it is processed the ring buffer uses two pointers called pin and pout to keep track of the data in the buffer the pointers were defined such that reading from the buffer is the simplest operation and only a single compare is needed to verify if the buffer is empty the buffer only stores events so the pointers point to these four byte entities as the dci specifies all data in bytes sizes have to be converted before reading data
ring buffer data structure	the pin and pout pointers are defined  as follows  pin	- last location filled with data  pout	- last empty location
ring buffer data structure	this definition results in the following  administration is simple but one location is wasted in the buffer full situation the pin pointer is one less that the pout pointer  buffer empty when the pin pointer and the pout pointer are equal
ring buffer data structure	a separate pointer indicates the end of the buffer pend this pointer points to the last available location in the buffer before advancing either  pointer it should be verified whether the pointer points to the last location in that case the pointer is reset to the start of the buffer  pointed to by pbuf otherwise it can just be incremented
command handling	the dpu accepts commands via two interfaces  from the spacecraft via the mil-std-1553 interface and from the icu via the ssi interface  any of the dpu commands can be sent from the scu or the icu  the source for a command from the dpu is one of the following  icu  command is generated and sent by the icu via the ssi  scu  command is generated and sent by the scu via the 1553  g-icu  command is generated on the ground and sent to the dpu via the icu/ssi  g-scu  command is generated on the ground and sent to the dpu via the scu/1553
normal data exchange sequence	the dpa csc calls tmaliwait to determine how many events are waiting to be read  when tmaliwait returns with a number greater than zero the dpa calls tmalinextevent for each event to be collected
global data	the global data items which are accessed by this csc
public functions	this routine provides a means to set the data timeout used by the dci the value requested indicates the timeout in milliseconds  the initial value for the frame depth setting is determined by the parameter provided when starting the tmalitask  the maximum value to which the timeout can be commanded is x seconds an attempt to set the timeout to a number larger than this maximum will result in setting the timeout to the default value of x milliseconds
public functions	this function gets the frame depth of the ping-pong buffers used by the dci csc  the frame depth determines how many frames are read into the selected ping-pong buffer before interrupting  the initial value for the frame depth setting is determined by the parameter provided when stating the tmalitask  the returned value is the current active value this may differ from the last commanded value as the commanded value only takes effect when data is transferred from the hardware ping-pong buffer to the tmali queue in response to a frame or timeout interrupt see section 51323
public functions	when no data is available in the tmali queue this routine blocks on a semaphore awaiting availability of events on the tmali queue as indicated by the isr  when data is already available on the tmali queue or the semaphore is taken the number of events on the tmali queue is determined and returned to the caller  the parameter tickstowait specifies the maximum time which the function can wait until data becomes available in kernel-ticks  the parameter may be set to a symbolic value forever which causes the function only to return when data is available  when the function is called with a timeout value and no data becomes avialable within that period the function will return zero events availableif the tmali task has not been initialized the function returns an error normal data exchange sequence	the tmali csc serves as an intermediate manager of event data supplied by the dci driver csc and eventually delivered to the dpa csc  the tmali csc waits for notification from the dci csc that a frame limit or data timeout has been reached in the ping-pong buffer indicating the event data is ready to be served to tmali   tmali reads all event data from the dci and notifies the dci that it can swap ping-pong buffers when ready   tmali gives a semaphore to unblock the tmaliwait call from the dpa